function calcAdler32(e){let t=1,n=0;const r=e.length;for(let i=0;i<r;i++)n=((t=(t+e[i])%65521)+n)%65521;return(n<<16)+t}const BTYPE=Object.freeze({UNCOMPRESSED:0,FIXED:1,DYNAMIC:2}),BLOCK_MAX_BUFFER_LEN=131072,LENGTH_EXTRA_BIT_LEN=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],LENGTH_EXTRA_BIT_BASE=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258],DISTANCE_EXTRA_BIT_BASE=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],DISTANCE_EXTRA_BIT_LEN=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],CODELEN_VALUES=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function generateHuffmanTable(e){const t=Object.keys(e);let n=0,r=0,i=Number.MAX_SAFE_INTEGER;t.forEach(e=>{n=Number(e),r<n&&(r=n),i>n&&(i=n)});let o,s=0;const a={};for(let t=i;t<=r;t++){void 0===(o=e[t])&&(o=[]),o.sort((e,t)=>e<t?-1:e>t?1:0);const n={};o.forEach(e=>{n[s]=e,s++}),a[t]=n,s<<=1}return a}function makeFixedHuffmanCodelenValues(){const e={7:[],8:[],9:[]};for(let t=0;t<=287;t++)t<=143?e[8].push(t):t<=255?e[9].push(t):t<=279?e[7].push(t):e[8].push(t);return e}function generateDeflateHuffmanTable(e,t=15){const n={};for(const t of e)n[t]?n[t]++:n[t]=1;const r=Object.keys(n);let i=[],o=0,s=[];if(1===r.length)s.push({count:n[0],simbles:[Number(r[0])]});else for(let e=0;e<t;e++){for(s=[],r.forEach(e=>{const t={count:n[Number(e)],simbles:[Number(e)]};s.push(t)}),o=0;o+2<=i.length;){const e={count:i[o].count+i[o+1].count,simbles:i[o].simbles.concat(i[o+1].simbles)};s.push(e),o+=2}(s=s.sort((e,t)=>e.count<t.count?-1:e.count>t.count?1:0)).length%2!=0&&s.pop(),i=s}const a={};let f;s.forEach(e=>{e.simbles.forEach(e=>{a[e]?a[e]++:a[e]=1})});const E=Object.keys(a),h={};let d=0,l=3,c=Number.MAX_SAFE_INTEGER,u=0;E.forEach(e=>{l=a[Number(e)],h[l]||(h[l]=[],c>l&&(c=l),u<l&&(u=l)),h[l].push(Number(e))}),d=0;const _=new Map;for(let e=c;e<=u;e++)(f=h[e])&&(f=f.sort((e,t)=>e<t?-1:e>t?1:0)).forEach(t=>{_.set(t,{code:d,bitlen:e}),d++}),d<<=1;return _}const REPEAT_LEN_MIN=3,FAST_INDEX_CHECK_MAX=128,FAST_INDEX_CHECK_MIN=16,FAST_REPEAT_LENGTH=8;function generateLZ77IndexMap(e,t,n){const r=t+n-REPEAT_LEN_MIN,i={};for(let n=t;n<=r;n++){const t=e[n]<<16|e[n+1]<<8|e[n+2];void 0===i[t]&&(i[t]=[]),i[t].push(n)}return i}function generateLZ77Codes(e,t,n){let r=t;const i=t+n-REPEAT_LEN_MIN;let o=0,s=0,a=0,f=0,E=0,h=0,d=0;const l=[],c={},u={},_=generateLZ77IndexMap(e,t,n);for(;r<=i;){const t=e[r]<<16|e[r+1]<<8|e[r+2],n=_[t];if(void 0===n||n.length<=1){l.push([e[r]]),r++;continue}o=r>32768?r-32768:0,a=0,f=0;let g=c[t]||0;for(;n[g]<o;)g=g+1|0;for(c[t]=g,g=u[t]||0;n[g]<r;)g=g+1|0;u[t]=g;let w=0;e:for(let i=u[t]-1,o=c[t];o<=i&&!(w>=FAST_INDEX_CHECK_MAX||a>=FAST_REPEAT_LENGTH&&w>=FAST_INDEX_CHECK_MIN);i--){w++;const t=n[i];for(let n=a-1;0<n;n--)if(e[t+n]!==e[r+n])continue e;s=258;for(let n=a;n<=258;n++)if(e[t+n]!==e[r+n]){s=n;break}if(a<s&&(a=s,f=t,258<=s))break}if(a>=3&&r+a<=i){E=r-f;for(let e=0;e<LENGTH_EXTRA_BIT_BASE.length&&!(LENGTH_EXTRA_BIT_BASE[e]>a);e++)h=e;for(let e=0;e<DISTANCE_EXTRA_BIT_BASE.length&&!(DISTANCE_EXTRA_BIT_BASE[e]>E);e++)d=e;l.push([h,d,a,E]),r+=a}else l.push([e[r]]),r++}return l.push([e[r]]),l.push([e[r+1]]),l}class BitWriteStream{constructor(e,t=0,n=0){this.nowBitsIndex=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t],this.nowBitsIndex=n}write(e){if(this.isEnd)throw new Error("Lack of data length");e<<=this.nowBitsIndex,this.nowBits+=e,this.nowBitsIndex++,this.nowBitsIndex>=8&&(this.buffer[this.bufferIndex]=this.nowBits,this.bufferIndex++,this.nowBits=0,this.nowBitsIndex=0,this.buffer.length<=this.bufferIndex&&(this.isEnd=!0))}writeRange(e,t){let n=1,r=0;for(let i=0;i<t;i++)r=e&n?1:0,this.write(r),n<<=1}writeRangeCoded(e,t){let n=1<<t-1,r=0;for(let i=0;i<t;i++)r=e&n?1:0,this.write(r),n>>>=1}}function deflate(e){const t=e.length,n=new BitWriteStream(new Uint8Array(t<BLOCK_MAX_BUFFER_LEN/2?BLOCK_MAX_BUFFER_LEN:2*t));let r=0,i=0;for(;r+BLOCK_MAX_BUFFER_LEN>=t?(i=t-r,n.writeRange(1,1)):(i=BLOCK_MAX_BUFFER_LEN,n.writeRange(0,1)),n.writeRange(BTYPE.DYNAMIC,2),deflateDynamicBlock(n,e,r,i),!((r+=BLOCK_MAX_BUFFER_LEN)>=t););return 0!==n.nowBitsIndex&&n.writeRange(0,8-n.nowBitsIndex),n.buffer.subarray(0,n.bufferIndex)}function deflateDynamicBlock(e,t,n,r){const i=generateLZ77Codes(t,n,r),o=[256],s=[];let a=256,f=0;for(let e=0,t=i.length;e<t;e++){const t=i[e];let n=t[0];const r=t[1];void 0!==r&&(n+=257,s.push(r),f<r&&(f=r)),o.push(n),a<n&&(a=n)}const E=generateDeflateHuffmanTable(o),h=generateDeflateHuffmanTable(s),d=[];for(let e=0;e<=a;e++)E.has(e)?d.push(E.get(e).bitlen):d.push(0);const l=d.length;for(let e=0;e<=f;e++)h.has(e)?d.push(h.get(e).bitlen):d.push(0);const c=d.length-l,u=[],_=[];let g=0,w=0;for(let e=0;e<d.length;e++){for(g=d[e],w=1;g===d[e+1];)if(w++,e++,0===g){if(138<=w)break}else if(6<=w)break;if(4<=w)0===g?11<=w?u.push(18):u.push(17):(u.push(g),_.push(1),w--,u.push(16)),_.push(w);else for(let e=0;e<w;e++)u.push(g),_.push(1)}const R=generateDeflateHuffmanTable(u,7);let T,B=0;CODELEN_VALUES.forEach((e,t)=>{R.has(e)&&(B=t+1)}),e.writeRange(l-257,5),e.writeRange(c-1,5),e.writeRange(B-4,4);for(let t=0;t<B;t++)void 0!==(T=R.get(CODELEN_VALUES[t]))?e.writeRange(T.bitlen,3):e.writeRange(0,3);u.forEach((t,n)=>{if(void 0===(T=R.get(t)))throw new Error("Data is corrupted");e.writeRangeCoded(T.code,T.bitlen),18===t?e.writeRange(_[n]-11,7):17===t?e.writeRange(_[n]-3,3):16===t&&e.writeRange(_[n]-3,2)});for(let t=0,n=i.length;t<n;t++){const n=i[t],r=n[0],o=n[1];if(void 0!==o){if(void 0===(T=E.get(r+257)))throw new Error("Data is corrupted");e.writeRangeCoded(T.code,T.bitlen),0<LENGTH_EXTRA_BIT_LEN[r]&&(w=n[2],e.writeRange(w-LENGTH_EXTRA_BIT_BASE[r],LENGTH_EXTRA_BIT_LEN[r]));const t=h.get(o);if(void 0===t)throw new Error("Data is corrupted");if(e.writeRangeCoded(t.code,t.bitlen),0<DISTANCE_EXTRA_BIT_LEN[o]){const t=n[3];e.writeRange(t-DISTANCE_EXTRA_BIT_BASE[o],DISTANCE_EXTRA_BIT_LEN[o])}}else{if(void 0===(T=E.get(r)))throw new Error("Data is corrupted");e.writeRangeCoded(T.code,T.bitlen)}}if(void 0===(T=E.get(256)))throw new Error("Data is corrupted");e.writeRangeCoded(T.code,T.bitlen)}class BitReadStream{constructor(e,t=0){this.nowBitsLength=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t],this.nowBitsLength=8}read(){if(this.isEnd)throw new Error("Lack of data length");const e=1&this.nowBits;return this.nowBitsLength>1?(this.nowBitsLength--,this.nowBits>>=1):(this.bufferIndex++,this.bufferIndex<this.buffer.length?(this.nowBits=this.buffer[this.bufferIndex],this.nowBitsLength=8):(this.nowBitsLength=0,this.isEnd=!0)),e}readRange(e){for(;this.nowBitsLength<=e;)this.nowBits|=this.buffer[++this.bufferIndex]<<this.nowBitsLength,this.nowBitsLength+=8;const t=this.nowBits&(1<<e)-1;return this.nowBits>>>=e,this.nowBitsLength-=e,t}readRangeCoded(e){let t=0;for(let n=0;n<e;n++)t<<=1,t|=this.read();return t}}class Uint8WriteStream{constructor(e){this.index=0,this.buffer=new Uint8Array(e),this.length=e,this._extendedSize=e}write(e){if(this.length<=this.index){this.length+=this._extendedSize;const e=new Uint8Array(this.length),t=this.buffer.length;for(let n=0;n<t;n++)e[n]=this.buffer[n];this.buffer=e}this.buffer[this.index]=e,this.index++}}const FIXED_HUFFMAN_TABLE=generateHuffmanTable(makeFixedHuffmanCodelenValues());function inflate(e,t=0){const n=new Uint8WriteStream(10*e.length),r=new BitReadStream(e,t);let i=0,o=0;for(;1!==i;){if(i=r.readRange(1),(o=r.readRange(2))===BTYPE.UNCOMPRESSED)inflateUncompressedBlock(r,n);else if(o===BTYPE.FIXED)inflateFixedBlock(r,n);else{if(o!==BTYPE.DYNAMIC)throw new Error("Not supported BTYPE : "+o);inflateDynamicBlock(r,n)}if(0===i&&r.isEnd)throw new Error("Data length is insufficient")}return n.buffer.subarray(0,n.index)}function inflateUncompressedBlock(e,t){e.nowBitsLength<8&&e.readRange(e.nowBitsLength);const n=e.readRange(8)|e.readRange(8)<<8;if(n+(e.readRange(8)|e.readRange(8)<<8)!==65535)throw new Error("Data is corrupted");for(let r=0;r<n;r++)t.write(e.readRange(8))}function inflateFixedBlock(e,t){const n=FIXED_HUFFMAN_TABLE,r=Object.keys(n);let i=0,o=0,s=Number.MAX_SAFE_INTEGER;r.forEach(e=>{i=Number(e),o<i&&(o=i),s>i&&(s=i)});let a,f,E,h,d,l,c,u,_=0;for(;!e.isEnd;){for(a=void 0,i=s,_=e.readRangeCoded(s);void 0===(a=n[i][_]);){if(o<=i)throw new Error("Data is corrupted");i++,_<<=1,_|=e.read()}if(a<256)t.write(a);else{if(256===a)break;E=LENGTH_EXTRA_BIT_BASE[f=a-257],0<(h=LENGTH_EXTRA_BIT_LEN[f])&&(E+=e.readRange(h)),d=e.readRangeCoded(5),l=DISTANCE_EXTRA_BIT_BASE[d],0<(c=DISTANCE_EXTRA_BIT_LEN[d])&&(l+=e.readRange(c)),u=t.index-l;for(let e=0;e<E;e++)t.write(t.buffer[u+e])}}}function inflateDynamicBlock(e,t){const n=e.readRange(5)+257,r=e.readRange(5)+1,i=e.readRange(4)+4;let o=0;const s={};for(let t=0;t<i;t++)0!==(o=e.readRange(3))&&(s[o]||(s[o]=[]),s[o].push(CODELEN_VALUES[t]));const a=generateHuffmanTable(s),f=Object.keys(a);let E=0,h=Number.MAX_SAFE_INTEGER;f.forEach(e=>{o=Number(e),E<o&&(E=o),h>o&&(h=o)});const d={},l={};let c,u=0,_=0,g=0;const w=n+r;for(let t=0;t<w;){for(c=void 0,o=h,u=e.readRangeCoded(h);void 0===(c=a[o][u]);){if(E<=o)throw new Error("Data is corrupted");o++,u<<=1,u|=e.read()}if(16===c?_=3+e.readRange(2):17===c?(_=3+e.readRange(3),g=0):18===c?(_=11+e.readRange(7),g=0):(_=1,g=c),g<=0)t+=_;else for(;_;)t<n?(d[g]||(d[g]=[]),d[g].push(t++)):(l[g]||(l[g]=[]),l[g].push(t++-n)),_--}const R=generateHuffmanTable(d),T=generateHuffmanTable(l),B=Object.keys(R);let A=0,N=0,b=Number.MAX_SAFE_INTEGER;B.forEach(e=>{A=Number(e),N<A&&(N=A),b>A&&(b=A)});const I=Object.keys(T);let L=0,S=0,m=Number.MAX_SAFE_INTEGER;I.forEach(e=>{L=Number(e),S<L&&(S=L),m>L&&(m=L)});let p,C,D,X,F,x,H,M,k,U,y=0;for(;!e.isEnd;){for(p=void 0,A=b,y=e.readRangeCoded(b);void 0===(p=R[A][y]);){if(N<=A)throw new Error("Data is corrupted");A++,y<<=1,y|=e.read()}if(p<256)t.write(p);else{if(256===p)break;for(D=LENGTH_EXTRA_BIT_BASE[C=p-257],0<(X=LENGTH_EXTRA_BIT_LEN[C])&&(D+=e.readRange(X)),F=void 0,M=m,k=e.readRangeCoded(m);void 0===(F=T[M][k]);){if(S<=M)throw new Error("Data is corrupted");M++,k<<=1,k|=e.read()}x=DISTANCE_EXTRA_BIT_BASE[F],0<(H=DISTANCE_EXTRA_BIT_LEN[F])&&(x+=e.readRange(H)),U=t.index-x;for(let e=0;e<D;e++)t.write(t.buffer[U+e])}}}
/**
 * @license Copyright (c) 2018 zprodev
 */function inflate$1(e){const t=new BitReadStream(e);if(8!==t.readRange(4))throw new Error("Not compressed by deflate");t.readRange(4),t.readRange(5),t.readRange(1),t.readRange(2);return inflate(e,2)}function deflate$1(e){const t=deflate(e),n=new BitWriteStream(new Uint8Array(1));n.writeRange(8,4),n.writeRange(7,4);const r=new BitWriteStream(new Uint8Array(1));r.writeRange(28,5),r.writeRange(0,1),r.writeRange(2,2);const i=new BitWriteStream(new Uint8Array(4)),o=calcAdler32(e);i.writeRange(o>>>24,8),i.writeRange(o>>>16&255,8),i.writeRange(o>>>8&255,8),i.writeRange(255&o,8);const s=new Uint8Array(t.length+6);return s.set(n.buffer),s.set(r.buffer,1),s.set(t,2),s.set(i.buffer,s.length-4),s}export{inflate$1 as inflate,deflate$1 as deflate};